#Get arguments of a command
# Takes the first target as command
Command := $(firstword $(MAKECMDGOALS))
# Skips the first word
Arguments := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))

# Database Constants
DATABASE_PROD_FILE_NAME=prod_dump.sql
DATABASE_CONTAINER_FILE_REPO=/database/
DATABASE_DUMP_FILE_PATH=./docker/database/local_dump_$(shell date +'%Y-%m-%d_%H:%M:%S').sql
DATABASE_FILE_REPO=./docker/database/
DATABASE_CONTAINER_NAME=etk_pgsql
DATABASE_CONTAINER_USER=root
LOCAL_DATABASE_NAME=estimatick

PROD_DATABASE_NAME= # Nom de la base de données de production
DATABASE_PROD_HOST= # Host de la base de données de production
DATABASE_PROD_USER= # Utilisateur de la base de données de production

# Other Constants
BRANCH_PREFIX=ETK-
PHP_CONTAINER_NAME=etk_php
NGINX_CONTAINER_NAME=etk_nginx
SHELL_GREEN_COLOR=\033[0;32m
SHELL_RED_COLOR=\033[0;31m
SHELL_RESET_COLOR=\033[0m

# Targets
%::
	@true

# List of commands available in the Makefile (Always keep it as the first target of the Makefile)
help:
	@echo "\n\033[1mCommandes make disponibles :\033[0m"
	@awk -F ':.*?## ' '/^[a-zA-Z0-9_-]+:.*?##/ { printf "  \033[36m make %-16s\033[0m 	: %s\n", $$1, $$2 }' $(MAKEFILE_LIST) | sort

# Other targets
branch: ## Crée une nouvelle branche en fonction du type et du nom
	@echo "$(SHELL_GREEN_COLOR)Choisissez le type de branche :$(SHELL_RESET_COLOR)"
	@echo "1) Feature"
	@echo "2) Bugfix"
	@echo "3) Hotfix"
	@read -p "Entrez le numéro correspondant au type de branche : " type; \
	case $$type in \
		1) prefix="feature"; cmd="update-develop";; \
		2) prefix="bugfix"; cmd="update-develop";; \
		3) prefix="hotfix"; cmd="update-main";; \
		*) echo "$(SHELL_GREEN_COLOR)Type invalide: utilisez 1 (feature), 2 (bugfix), ou 3 (hotfix)$(SHELL_RESET_COLOR)"; exit 1;; \
	esac; \
	read -p "Entrez le nom de la branche : " name; \
	if [[ $$name =~ ^[0-9]+$$ ]]; then \
		nom="$(BRANCH_PREFIX)$$name"; \
	else \
		nom="$$name"; \
	fi; \
	echo "$(SHELL_GREEN_COLOR)Création de la branche : $$prefix/$$nom$(SHELL_RESET_COLOR)"; \
	make $$cmd; \
	git switch -c $$prefix/$$nom

drop-database: ## Supprime la base de données
	@echo "$(SHELL_GREEN_COLOR)Suppression de la base de données ...$(SHELL_RESET_COLOR)"
	@docker exec -it $(DATABASE_CONTAINER_NAME) dropdb -U $(DATABASE_CONTAINER_USER) $(LOCAL_DATABASE_NAME)
	@echo "$(SHELL_GREEN_COLOR)Suppression terminée avec succès$(SHELL_RESET_COLOR)"
	@echo "$(SHELL_GREEN_COLOR)Création de la base de données vide ...$(SHELL_RESET_COLOR)"
	@docker exec -it $(DATABASE_CONTAINER_NAME) createdb -U $(DATABASE_CONTAINER_USER) $(LOCAL_DATABASE_NAME)
	@echo "$(SHELL_GREEN_COLOR)Création terminée avec succès$(SHELL_RESET_COLOR)"

dump-database: ## Fait un dump de la base de données
	@echo "$(SHELL_GREEN_COLOR)Dump de la base de données ...$(SHELL_RESET_COLOR)"
	@docker exec -it $(DATABASE_CONTAINER_NAME) pg_dump -U $(DATABASE_CONTAINER_USER) -O -x  $(LOCAL_DATABASE_NAME) > $(DATABASE_DUMP_FILE_PATH)
	@echo "$(SHELL_GREEN_COLOR)Dump terminé avec succès dans le fichier $(DATABASE_DUMP_FILE_PATH)$(SHELL_RESET_COLOR)"

import-database: ## Importe la base de données depuis le fichier spécifié en argument ou depuis la base de données de production
	@if [ -n "$(Arguments)" ]; then \
  		if [ -f $(DATABASE_FILE_REPO)$(Arguments) ]; then \
			echo "$(SHELL_GREEN_COLOR)Importation du fichier $(Arguments) dans la base de données ...$(SHELL_RESET_COLOR)"; \
			docker exec -it $(DATABASE_CONTAINER_NAME) psql -d $(LOCAL_DATABASE_NAME) -f $(DATABASE_CONTAINER_FILE_REPO)$(Arguments); \
			echo "$(SHELL_GREEN_COLOR)Importation terminée avec succès$(SHELL_RESET_COLOR)"; \
		else \
			echo "$(SHELL_RED_COLOR)Fichier $(Arguments) non trouvé dans le répertoire $(DATABASE_FILE_REPO)$(SHELL_RESET_COLOR)"; \
		fi; \
	else \
		if [ ! -f $(DATABASE_FILE_REPO)$(DATABASE_PROD_FILE_NAME) ]; then \
			echo "$(SHELL_RED_COLOR)Fichier $(DATABASE_FILE_REPO)$(DATABASE_PROD_FILE_NAME) non trouvé$(SHELL_RESET_COLOR)"; \
      		echo "$(SHELL_GREEN_COLOR)Téléchargement du fichier depuis la base de données de production ...$(SHELL_RESET_COLOR)"; \
      		read -sp "Entrez le mot de passe pour l'utilisateur $(DATABASE_PROD_USER): " DB_PROD_PASSWORD; echo ""; \
      		if docker exec -it $(DATABASE_CONTAINER_NAME) /bin/bash -c "PGPASSWORD='$$DB_PROD_PASSWORD' pg_dump -U $(DATABASE_PROD_USER) -h $(DATABASE_PROD_HOST) -O -x $(PROD_DATABASE_NAME)" > $(DATABASE_FILE_REPO)$(DATABASE_PROD_FILE_NAME); then \
				echo "$(SHELL_GREEN_COLOR)Authentification réussie !$(SHELL_RESET_COLOR)"; \
				echo "$(SHELL_GREEN_COLOR)Téléchargement terminé avec succès$(SHELL_RESET_COLOR)"; \
			else \
				echo "$(SHELL_RED_COLOR)Échec de l'authentification ou de la connexion à la base de données$(SHELL_RESET_COLOR)"; \
				exit 1; \
			fi; \
    	fi; \
		echo "$(SHELL_GREEN_COLOR)Importation du fichier $(DATABASE_PROD_FILE_NAME) dans la base de données ...$(SHELL_RESET_COLOR)"; \
		docker exec -i $(DATABASE_CONTAINER_NAME) psql -d $(LOCAL_DATABASE_NAME) -f $(DATABASE_CONTAINER_FILE_REPO)$(DATABASE_PROD_FILE_NAME); \
		echo "$(SHELL_GREEN_COLOR)Importation terminée avec succès$(SHELL_RESET_COLOR)"; \
	fi

init: ## Initialise l'environnement de développement
	@make start
	@make install-vendor
	@make import-database

install-vendor: ## Installe les dépendances Composer du projet
	@docker exec -it $(PHP_CONTAINER_NAME) composer install

migrate: ## Exécute les migrations
	@docker exec -it $(PHP_CONTAINER_NAME) php bin/console doctrine:migrations:migrate

migration: ## Crée une migration
	@docker exec -it $(PHP_CONTAINER_NAME) php bin/console make:migration

php: ## Rentre dans le container PHP
	@docker compose exec -it $(PHP_CONTAINER_NAME) bash

phpcbf: ## Corrige automatiquement les erreurs de style de code avec PHP Code Beautifier
	@docker exec -it $(PHP_CONTAINER_NAME) vendor/bin/phpcbf --standard=phpcs.xml ./

phpcs: ## Exécute PHP Code Sniffer pour vérifier le style de code
	@docker exec -it $(PHP_CONTAINER_NAME) vendor/bin/phpcs --standard=phpcs.xml ./

phpcsfixer: ## Exécute php-cs-fixer
	@docker exec -it $(PHP_CONTAINER_NAME) vendor/bin/php-cs-fixer fix -vvv --show-progress=dots

phpstan: ## Exécute phpstan
	@docker exec -it $(PHP_CONTAINER_NAME) vendor/bin/phpstan analyse --memory-limit 512M

reset-database: ## Réinitialise la base de données
	@make drop-database
	@make import-database
	@make migrate

restart: ## Redémarre l'environnement de développement
	@make stop
	@make start

sf: ## Exécute une commande Symfony
	@docker exec -it $(PHP_CONTAINER_NAME) php bin/console $(Arguments)

start: ## Démarre l'environnement de développement
	@docker compose up -d
	@make setup-geojson
	@make watch-assets

stop: ## Arrête l'environnement de développement
	@docker compose down

twigcsfixer: ## Run TWIG-CS-Fixer
	@docker exec -it $(PHP_CONTAINER_NAME) ./vendor/bin/twig-cs-fixer lint --fix ./templates/

update-develop: ## Met à jour la branche develop
	@git switch develop
	@make update-from-develop

update-from-develop: ## Met à jour la branche courante depuis la branche develop
	@common_steps() { \
         		git fetch --prune; \
         		git rebase origin/develop; \
         	}; \
    	if [ $(shell git ls-files -md|wc -l) -gt 0 ]; then \
    		git stash; \
            common_steps; \
            git stash pop; \
    	else \
    		common_steps; \
    	fi; \

update-from-main: ## Met à jour la branche courante depuis la branche main
	@common_steps() { \
             		git fetch --prune; \
             		git rebase origin/main; \
             	}; \
        	if [ $(shell git ls-files -md|wc -l) -gt 0 ]; then \
        		git stash; \
                common_steps; \
                git stash pop; \
        	else \
        		common_steps; \
        	fi; \

update-main: ## Met à jour la branche main
	@git switch main
	@make update-from-main

update-vendor: ## Met à jour les dépendances Composer du projet
	@docker exec -it $(PHP_CONTAINER_NAME) composer update

watch-assets: ## Exécute la commande pour compiler les assets en mode watch
	@echo "Lancement de la commande pour compiler les assets en mode watch..."
	@docker exec -it $(PHP_CONTAINER_NAME) php bin/console tailwind:build --watch
